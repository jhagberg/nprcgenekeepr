---
title: "Interactive Use of nprcmanager"
output:
  html_document:
    df_print: paged
vignette: |
  %\VignetteEngine{knitr::knitr} 
  %\VignetteIndexEntry{Genetic Management Tools} 
  %\usepackage[UTF-8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,include=TRUE, results="markup")
```

```{r, include = FALSE}
library(nprcmanager)
library(stringi)
suppressMessages(library(ggplot2))
library(knitr)
library(rmsutilityr)

```

## Introduction

## Reading in Pedigrees

Pedigrees can be imported using Excel worksheets, text files, and by using
a list of animals where the remainder of the pedigree information comes
in through the LabKey API.

This tutorial will use a pedigree file that can be created using the 
__makeExamplePedigreeFile__ function as shown below.
The function __makeExamplePedigreeFile__ both saves a file and returns the
full path name to the saved file, which we are saving into the variable _pedigreeFile_.
Note: the user will select where to store the file.
```{r make-example-pedigree, eval = FALSE, include = TRUE}
library(nprcmanager)
pedigreeFile <- makeExamplePedigreeFile()

```
This writes _ExamplePedigree.csv_ to a place you select within your file
system.

```{r get-file-name, eval = TRUE, echo = FALSE, include = FALSE}
pedigreeFile <- "/Users/msharp/Desktop/ExamplePedigree.csv"


```

You use the file name provided by the __makeExamplePedigreeFile__ function
to tell __read.table__ what file to read.

There 
```{r read-in-example-pedigree}
breederPedCsv <- read.table(pedigreeFile, sep = ",", header = TRUE,
                            stringsAsFactors = FALSE)
```
Note the number of rows read.
```{r row-count}
nrow(breederPedCsv)
```

The next step is to put the information in the file format into a 
pedigree object. This is done with the __qcStudbook__ function, which examines 
the file contents and tests for common pedigree errors.

You can see the errors that can be detected by __qcStudbook__ by returning the
empty error list with __getEmptyErrorLst()__. 
We are not showing the output of the function call now 
because later in this tutorial we will explore errors in more depth.

__qcStudbook__ can take four arguments _sb_, _minParentAge_ (in years), _reportChanges_,
and _reportErrors_. However, all but _sb_ have default values and only the
_sb_ argument is required.

It is prudent to ensure that parents are at least of breeding age, which
is species specific.
I have used a _minParentAge_ of 2 years.[^1]

[^1]: Setting the _minParentAge_ to 3.5 and above will cause an error along
with the creation of a file _~/lowParentAge.csv_ that will list the parents
with low age at the birth of an offspring.



```{r form-pedigree-object}
breederPed <- qcStudbook(breederPedCsv, minParentAge = 2)

```

If __qcStudbook__ reports and error, change the call by adding the __reportErrors__
argument set to __TRUE__ and examine the returned object.
More on this is presented in the __Pedigree Errors__ section.

## Identifying Focal Animals

You may want to focus your work on a _focal_ group of animals. 
This can be done by reading in a list of animal IDs of the _focal_
animals and use that list to update the pedigree.
Alternatively you can created a list of animal IDs based on 
criteria you have selected. 

For example, to select living animals at the facility with at least one parent,
the following can be used.

```{r select-focal-animals-from-pedigree, results='asis'}
focalAnimals <- breederPed$id[!(is.na(breederPed$sire) & is.na(breederPed$dam)) &
                                is.na(breederPed$exit)]
print(stri_c("There are ", length(focalAnimals), " animals in the vector _focalAnimals_."))

```

As can be seen, these animals have at least one parent and have not left the
facility.

```{r short-pedigree-list-of-focal-animals}
breederPed[breederPed$id %in% focalAnimals, c("id", "sire", "dam", "exit")][1:10, ]

```

We indicate that these are the animals of interest by using the
__setPopulation__ function. 
This function simply sets a column named _population_ to the logical value of
__TRUE__ if the row represents an animal in the list and __FALSE__ otherwise.

The first line of code below sets the _population_ column and the second 
counts the number of rows where the value was set to __TRUE__.

```{r set-population-flag}
breederPed <- setPopulation(ped = breederPed, ids = focalAnimals)
nrow(breederPed[breederPed$population, ])

```

The IDs used to populate the _population_ flag can be used to trim the pedigree 
so that it contain only those 
individuals who are in the ID list or are ancestors of those individuals.



```{r trim-pedigree}
trimmedPed <- trimPedigree(focalAnimals, breederPed)
nrow(breederPed); nrow(trimmedPed)

```

The __trimPedigree__ function has the ability to also remove those ancestors 
that do not contribute genetic information.
Uninformative founders are those individuals who are parents of only
one individual and who have no parental information. 
(_Currently genotypic information is ignored by __trimPedigree___).

```{r removed-uninformatiive-animals}
trimmedPedInformative <- trimPedigree(focalAnimals, breederPed,
                                      removeUninformative = TRUE)
nrow(trimmedPedInformative)

```

We can find all of the animals that are in the trimmed pedigree but are not
focal animals.
```{r get-animals-added-to-focal-animals}
nonfocalInTrimmedPed <- trimmedPed$id[!trimmedPed$id %in% focalAnimals]
length(nonfocalInTrimmedPed)

```

We can see which of these `r length(nonfocalInTrimmedPed)` are and are not
parents.
We will first make sure we have all of the parents by getting our list of
parents from the entire pedigree. 
We then demonstrate that they are all in the trimmed pedigree.
```{r find-focal-parents}
allFocalParents <- c(breederPed$sire[breederPed$id %in% focalAnimals], 
                       breederPed$dam[breederPed$id %in% focalAnimals])
trimmedFocalParents <- c(trimmedPed$sire[trimmedPed$id %in% focalAnimals], 
                       trimmedPed$dam[trimmedPed$id %in% focalAnimals])
all.equal(allFocalParents, trimmedFocalParents)

```

However, not all of the animals in the trimmed pedigree are either
the focal animals or their parents. 

```{r find-non-focal-non-focal-parent}
notFocalNotParent <- trimmedPed$id[!trimmedPed$id %in% c(focalAnimals, allFocalParents)]
length(notFocalNotParent)

```


```{r find-grandparents, echo = FALSE, include=FALSE, eval = TRUE}
allFocalGrandParents <- c(breederPed$sire[breederPed$id %in% allFocalParents],
                          breederPed$dam[breederPed$id %in% allFocalParents])
## Not all parents are known so the unknown individuals (NA) are removed.
allFocalGrandParents <- allFocalGrandParents[!is.na(allFocalGrandParents)] 
trimmedFocalGrandParents <- c(trimmedPed$sire[trimmedPed$id %in% allFocalParents],
                          trimmedPed$dam[trimmedPed$id %in% allFocalParents])
trimmedFocalGrandParents <- trimmedFocalGrandParents[!is.na(trimmedFocalGrandParents)] 
all.equal(allFocalGrandParents, trimmedFocalGrandParents)

```
Since the trimming process is supposed to retain the focal animals
and their ancestors, we will leave it as an exercise for you to demonstrate
that at least some of the remaining animals are grandparents of the focal
animals. _Hint: there are `r length(trimmedFocalGrandParents)` grandparents
in both the trimmed and the complete pedigree_.


```{r get-informative-and-uninformative-added-animals, echo=FALSE, include=FALSE, eval=TRUE}
trimmedPedInformative <- trimPedigree(focalAnimals, breederPed,
                                            removeUninformative = TRUE)
uninformative <- trimmedPed$id[!trimmedPed$id %in% trimmedPedInformative$id]
notFocalInTrimmedPed <- trimmedPed$id[!trimmedPed$id %in% focalAnimals]

```

As you can see from the number of rows in the full pedigree 
(`r nrow(breederPed)`) versus the trimmed pedigree (`r nrow(trimmedPed)`),
trimmed pedigrees can be much smaller. 
Of the additional `r nrow(trimmedPed) - length(focalAnimals)` animals, 
`r nrow(trimPedigree(focalAnimals, breederPed, removeUninformative = TRUE)) - length(focalAnimals)`
provide genetic information while the others 
(`r length(uninformative)`) are genetically uninformative.


```{r animals-no-birth-no-exit, echo = FALSE, eval = TRUE, include=FALSE}
unknownBirth <- breederPed$id[is.na(breederPed$birth)]
unknownBirthOrExit <- breederPed$id[is.na(breederPed$birth) | !is.na(breederPed$exit)]
knownPed <- breederPed[!breederPed$id %in% unknownBirthOrExit, ]
otherIds <- knownPed$id[!knownPed$id %in% trimmedPed$id[is.na(trimmedPed$exit)]]

```

As is shown below only `r length(otherIds)` (`r rmsutilityr::get_and_or_list(otherIds)`)
living animals are still in the colony but are not in the trimmed pedigree.


```{r show-animals-no-birth-no-exit, results = 'asis'}
unknownBirth <- breederPed$id[is.na(breederPed$birth)]
unknownBirthOrExit <- breederPed$id[is.na(breederPed$birth) | !is.na(breederPed$exit)]
knownPed <- breederPed[!breederPed$id %in% unknownBirthOrExit, ]
otherIds <- knownPed$id[!knownPed$id %in% trimmedPed$id[is.na(trimmedPed$exit)]]
print(stri_c("The living animal in the pedigree that are not in the trimmed ",
             "pedigree are ", get_and_or_list(otherIds), "."))

```



## Age Sex Pyramid Plot

You can examine the population structure using an age-sex pyramid plot with a 
single function. 
We will limit our view to just the focal animals and their living relatives.
This is appropriate for colony management because in addition to the genetic
diversity we seek, we have to remain cognacent of the age and sex distributions
within the colonies we manage.


```{r plot-focal-age-sex-pyramid, include = TRUE}
getPyramidPlot(ped = trimmedPed[is.na(trimmedPed$exit), ])

```


## Genetic Value Analysis

Your genetic value analysis must be carefully performed. 
The next three commands set up the entire pedigree for analysis.
```{r set-entire-pedigree-as-population}
ped <- setPopulation(breederPed, NULL)

```

```{r full-pedigree-genetic-value-summary}
probands <- ped$id[ped$population]
ped <- trimPedigree(probands, ped, removeUninformative = FALSE,
                    addBackParents = FALSE)

## Need a brief discussion of iterations (guIter), threshold (guThresh),
## and byID.

geneticValue <- reportGV(ped, guIter = 500,
                         guThresh = 3,
                         byID = TRUE,
                         updateProgress = NULL)
summary(geneticValue)

```
What happens if we limit our analysis to the trimmed pedigree?
Remember that the trimmed pedigree still contains all of the genetic
information that the full pedigree has for the focal animals.
```{r trimmed-genetic-value-analysis}

trimmedGeneticValue <- reportGV(trimmedPed, guIter = 500,
                         guThresh = 3,
                         byID = TRUE,
                         updateProgress = NULL)
summary(trimmedGeneticValue)
```
It is clear that limiting your analysis to the animals of interest
reduces the effort required to examine the animals of interest.

**Detailed look at the genetic value report**

```{r look-at-genetic-value-report}
rpt <- trimmedGeneticValue[["report"]]
g <- rpt
g$indivMeanKin <- round(g$indivMeanKin, 5)
g$zScores <- round(g$zScores, 2)
g$gu <- round(g$gu, 5)
g <- toCharacter(g)
names(g) <- headerDisplayNames(names(g))
knitr::kable(g[1:10, ]) # needs more work for display purposes.
```
```{r kinship-and-founders}
kmat <- trimmedGeneticValue[["kinship"]]
f <- trimmedGeneticValue[["total"]]
mf <- trimmedGeneticValue[["maleFounders"]]
ff <- trimmedGeneticValue[["femaleFounders"]]
fe <- trimmedGeneticValue[["fe"]]
fg <- trimmedGeneticValue[["fg"]]

mk <- rpt[, "indivMeanKin"]
gu <- rpt[, "gu"]
guBox <- ggplot(data.frame(gu = gu), aes(x = "", y = gu)) +
  geom_boxplot(
    color = "darkblue",
    fill = "lightblue",
    notch = TRUE,
    outlier.color = "red",
    outlier.shape = 1
  ) +
  theme_classic() + geom_jitter(width = 0.2) + coord_flip() +
  ylab("Score")  + ggtitle("Genetic Uniqueness")
print(guBox)

gu <- rpt[, "indivMeanKin"]
gu <- rpt[, "zScores"]
```

To use the __findLoops__ function run the following code and select a pedigree 
as your input file that has a loop in it. 
We are continuing to use the example pedigree that comes with the software
_Example_Pedigree.csv_.

```{r look-at-loops}
exampleTree <- createPedTree(breederPed)
exampleLoops <- findLoops(exampleTree)

```
You can count how many loops you have with the following code.
```{r countLoops}
length(exampleLoops[exampleLoops == TRUE])
nLoops <- countLoops(exampleLoops, exampleTree)
sum(unlist(nLoops[nLoops > 0]))

```

You can list the first 10 sets of ids, sires and dams in loops with the following line of code:

```{r listLoops}

examplePedigree[exampleLoops == TRUE, c("id", "sire", "dam")][1:10, ]


```
